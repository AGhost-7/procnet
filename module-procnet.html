<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Module: procnet</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Module: procnet</h1>

    




<section>

<header>
    
        
    
</header>

<article>
    <div class="container-overview">
    
        

        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".client"><span class="type-signature">(static) </span>client<span class="signature">(factories, config)</span><span class="type-signature"></span></h4>

    



<div class="description">
    A client is nothing more than a consumer. A good example would be a  server 
with a REST api trying to call remote services using procnet. It could of 
course also be a browser client trying to fetch data from remote servers.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>factories</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Contains all of the instanciators for the service 
types.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>config</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Has the configuration for each of the services.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line164">line 164</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>loader</li>
        </ul>
    </dd>
    

    
</dl>
















        
            

    

    <h4 class="name" id=".dependencies"><span class="type-signature">(static) </span>dependencies<span class="signature">(serviceFactory)</span><span class="type-signature"></span></h4>

    



<div class="description">
    Returns the dependencies that need to be resoled and passed to the factory
to create a service instance.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>serviceFactory</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">The factory which is used to create the
service;</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line64">line 64</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    array
</div>



    



        
            

    

    <h4 class="name" id=".injectable"><span class="type-signature">(static) </span>injectable<span class="signature">()</span><span class="type-signature"></span></h4>

    















<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line57">line 57</a>
    </li></ul></dd>
    

    

    

    
</dl>
















        
            

    

    <h4 class="name" id=".loader"><span class="type-signature">(static) </span>loader<span class="signature">(factories, config)</span><span class="type-signature"></span></h4>

    



<div class="description">
    Asynchronous dependency loader for setting up services. This will load up 
the service and return the precedures object that the service generates.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>factories</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Is a map of service names which translate to a 
function accepting an option and a callback.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>config</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">The configuration is used to store data which could 
be server-specific as well as other things such as ip addresses. Each 
factory is given the corresponding configuration needed to create the 
instance it is being asked to generate.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line134">line 134</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    function
</div>



    



        
            

    

    <h4 class="name" id=".mockCluster"><span class="type-signature">(static) </span>mockCluster<span class="signature">(promise, leafs, branches)</span><span class="type-signature"></span></h4>

    



<div class="description">
    This allows you to more or less do integration testing while still avoiding
to make network calls.

<code><pre>

var leafs = {
  postgres: function() {},
  math: procnet.mockRemote(math)
};

var recangle = procnet.service(['math'], function(math) {
  return {
    surface: function(w, h) {
      return math.multiply(w, w);
    }
  };
});

var services = procnet.mockCluster(leafs, { rectangle: rectangle });

services.rectangle.surface(10, 2).then(function(res) {
  assert.equal(res, 20);
});
</pre></code>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>promise</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Is yet again, a promise factory.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>leafs</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">These are already loaded dependencies. For example,
if you still want to have a real database connection, you can inject it into
the cluster by adding its name and reference to the object.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>branches</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Are services which need to be mocked.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line319">line 319</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    object
</div>



    



        
            

    

    <h4 class="name" id=".mocker"><span class="type-signature">(static) </span>mocker<span class="signature">(promise, mocks, service)</span><span class="type-signature"></span></h4>

    



<div class="description">
    To unit test, one will need to use mocking due to the services having 
external dependencies. Since procnet is so simple, you can still call 
directly the procedures once the service is instantianted.

<code><pre>
var rectangle = procnet.service(['math'], function(math) {
  return {
    surface: function(a, b) {
      return math.multiply(a, b);
    }
  };
});

var mock = procnet.mocker(promiseFactory);

var mocked = mock({
  math: {
    multiply: function(a, b) { return a + b; }
  }
}, rectangle);

mocked
  .surface(2, 5)
  .then(function(r) {
    assert.equal(r, 7);
  });
</pre></code>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>promise</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">is the promise factory</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>mocks</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">is an object where the key is the name of the service.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>service</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">is the function returning an object will all of 
the procedures.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line272">line 272</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    function
</div>



    



        
            

    

    <h4 class="name" id=".mockFn"><span class="type-signature">(static) </span>mockFn<span class="signature">(promise, fn)</span><span class="type-signature"></span></h4>

    



<div class="description">
    Utility function for mocking service procedures for unit testing. It only 
makes the function always returna promise, which generated services don't 
always do.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>promise</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Is a promise factory.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Is the function to mock.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line192">line 192</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    function
</div>



    



        
            

    

    <h4 class="name" id=".mockRemote"><span class="type-signature">(static) </span>mockRemote<span class="signature">(promise, mock)</span><span class="type-signature"></span></h4>

    



<div class="description">
    Takes in a object with functions and ensures that they always return a 
promise. Useful for injecting them into services as fake networked remotes.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>promise</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">is a promise factory.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>mock</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">is the set of functions to mock. Can also contain 
objects, where the functons inside of that object will be mocked.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line250">line 250</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    object
</div>



    



        
            

    

    <h4 class="name" id=".resolve"><span class="type-signature">(static) </span>resolve<span class="signature">(toResolve)</span><span class="type-signature"> &rarr; {object|promise}</span></h4>

    



<div class="description">
    Similar to loader, but instead is synchronous. More useful if you're just
using this library for dependency injection. Its really just synchronous
by default instead of forcing all functions to return a promise.

<code><pre>

var math = procnet.injectable(function() {
  return {
    add: function(a, b) { return a + b; },
    double: function(a) { return a * 2; }
  };
});

var rectangle = procnet.injectable(['math'], function(math) {
  return {
    perimeter: function(h, w) {
      return math.add(math.double(h), math.double(w));
    }
  };
});

var services = {
  'rectangle': rectangle,
  'math': math
};

var loaded = procnet.resolve(services);

console.log(loaded.perimeter(1, 1)); // => 4
</pre></code>


This function also supports async dependency loading, where an injectable
returns a promise instead of a instance. In this case the function will
return a promise. This is useful for injectables which need to load data
from databases and such.

<code><pre>
var numberCache = procnet.injectable(function() {
  return Promise.resolve({
    1: 'One',
    2: 'Two',
    3: 'Three'
  });
});
var add = procnet.injectable(function(numberCache) {
  return function(x, y) { return x + y; };
});

var loadedAsync = procnet.resolve({
  numberCache: numberCache,
  add: add
});
loadedAsync.then(function(loaded) {
  loaded.add(1, 2); // => 'Three'
});
</pre></code>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>toResolve</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Is the list of services that are either already
loaded or need to be loaded.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line487">line 487</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    All the services loaded. If some of the service instances are
returned as promises then the object returned will also be a promise.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">object</span>
|

<span class="param-type">promise</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".rollingFn"><span class="type-signature">(static) </span>rollingFn<span class="signature">(promise, values, ln)</span><span class="type-signature"></span></h4>

    



<div class="description">
    Function which will return each value specified in the array in sequence
for each call. Each value will be promisified.

<code><pre>
var values = [1, 2];

var roller = procnet.rollingFn(promise, values);

roller('foobar?'); // -> returns a resolved promise with the value 1.
roller('foobaz!'); // -> returns a resolved promise with the value 2.
roller('fooboo');  // -> returns a resolved promise with the value undefined.

</pre></code>

This is useful for mocking functions such as database access functions.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>promise</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Is a promise factory.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>values</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>


            
            </td>

            

            

            <td class="description last">Are the values the function will return on each
subsequent call.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ln</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last">Is the length property of the function. This parameter is
optional.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line213">line 213</a>
    </li></ul></dd>
    

    

    

    
</dl>
















        
            

    

    <h4 class="name" id=".service"><span class="type-signature">(static) </span>service<span class="signature">(dependencies, factory)</span><span class="type-signature"></span></h4>

    



<div class="description">
    More like syntatic sugar for defining services. You can list your dependencies
array to query them later.
<code><pre>
var foo = procnet.service(['bar'], function(bar) {
  return {
    foobar: function() { return 'foo' + bar; }
  };
});
procnet.dependencies(foo); // => ['bar']
var instance = foo('bar');
instance.foobar(); // => 'foobar'
</pre></code>

You also have the option of omitting the array and listing your dependencies
directly just like with angular modules. It will infer what you mean
automatically.
<code><pre>
var rectangle = procnet.injectable(function(math) {
  return {
    perimeter: function(h, w) {
      return math.add(math.double(h), math.double(w));
    }
  };
});
procnet.dependencies(rectangle); // => ['math']
</pre></code>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>dependencies</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>


            
            </td>

            

            

            <td class="description last">Is an array of strings where each string is the
name of the service that the service requires to run.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>factory</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">Is the funciton which returns the list of 
procedures.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line12">line 12</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    function
</div>



    



        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-procnet.html">procnet</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Mar 10 2016 21:05:22 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>