{
  "name": "pogostick-proto",
  "version": "1.1.4",
  "description": "Pogostick protocol functions",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/AGhost-7/pogostick.git"
  },
  "contributors": [
    {
      "name": "Jonathan Boudreau",
      "email": "jonathan.boudreau.92@gmail.com"
    }
  ],
  "scripts": {
    "ci": "npm run lint && npm run test",
    "test": "mocha",
    "lint": "jshint ."
  },
  "main": "index.js",
  "author": {
    "name": "AGhost-7"
  },
  "keywords": [
    "rpc",
    "server",
    "client"
  ],
  "engines": {
    "node": ">= 0.12"
  },
  "license": "MIT",
  "devDependencies": {
    "bluebird": "^2.9.34",
    "chai": "^3.2.0",
    "jshint": "^2.8.0",
    "lodash": "^3.10.1",
    "mocha": "^2.3.0"
  },
  "dependencies": {
    "extend": "^3.0.0",
    "mk-fn": "^1.0.0"
  },
  "pre-commit": [
    "lint",
    "validate",
    "test"
  ],
  "readme": "# TODO\nUpdate the protocol to include the length property for functions. This way you can use curry functionalities and other things which rely on the `length` property.\n\n# Goal\n\nThe goal is to have a promises-based, high performance, and transport-agnostic RPC library.\n\nDuplex connections are achieved by having a “client” and a “server” on both sides of the connection.\n\nnote: dnode is good, but doesn’t keep in mind failures the way I think a resilient system should.\n\nThe question is, how to handle this in a rpc system in NodeJS?\n\nAlso, dnode doesn’t handle deep objects, which sort of sucks. I want namespaces.\n\nThe goal of defining a protocol for such a library is to make it easier to support different \ntransports. It should be possible to adapt this to use websockets, plain old HTTP, TCP, or even UDP.\n\n# Protocol\n\nThe protocol is composed of five methods. `ls`, `init`, `call`, `res`, `err` and `exit`. The method \nbeing called is specified on the first line of the message. Each argument following are separated by\na line break.\n\nIdentification of the remote calls is necessary for the implementation in raw protocols such as TCP \nor UDP. Since the Pogostick protocol is transport agnostic, it includes such a requirement, even for\n the HTTP/HTTPS implementation.\n\n# Network Implementation\n\nCurrently, I think I will stick to http/https since implementing the protocol on tcp properly will \nbe a bit too hairy to be worthwhile, especially considering http is implemented using libuv under \nthe hood. Thanks to keepalive, http is still a fairly good choice even for applications with lots of\nfrequent requests.\n\n# Protocol Methods\n\n## Proc Listing: `ls`\n\nThis is to enable compatibility with the implementation in http. The client must initialize \ncommunication by sending a ls request to the server. Server does not send the init packet until ls \nis requested.\n\n\tls              -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\n\n## Initializer: `init`\n\nIn the initial request done by the client, the method listing for the server is sent to the client. \nThis allows the api to be defined directly on the client object given by the connection constructor.\nThe protocol permits to transfer arrays and objects for the purpose of namespacing. Strings and \nnumbers are not transferred over by the protocol, and are ignored by the client.\n\nFor example:\n\n\tinit                          -> Method Name\n\t1439948538953                 -> Unix Timestamp\n\t3d532EfEQC                    -> 10 Random [A-z0-9] Chars\n\t{“add”:true,”multiply”:true}  -> Procedure Listing\n\nAnother example:\n\n\tinit\n\t1439948538953                         -> Unix Timestamp\n\t3d532EfEQC                            -> 10 Random [A-z0-9] Chars\n\t{“add”: {“default”:true,”two”:true}}  -> Procedure Listing\n\n## Function Call: `call`\n\nThe call method is sent by the client to the server to request information, or just signal a change \nof state. Since it is possible for multiple requests to be pending, the next arguments a timestamp.\nlong with a pseudo-random string is submitted to a maximum length of 10 characters, valid characters\n are A-z and 0-9. The fourth argument is the procedure’s name, and the last are the arguments. Only \nthe arguments are a valid json array, where each element is an argument to be feed to the procedure \ncall.\n\nNote: As long as there is still a connection, the server must respond.\n\n\tcall            -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\tadd.default     -> Procedure Call Name\n\t[1,2]           -> Arguments Array\n\n## Function Response: `res`\n\nStamp must be the stamp the client sent when the procedure was called.\n\n\tres             -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\t3               -> Result\n\n## Function Error: `err`\n\n\terr             -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\t“Error!”        -> JSON value (string|number|object|integer)\n\n## Closing Connection: `exit`\n\nExit can either represent a fatal error or a request by the client/server to end the connection. \nThe second and third arguments are optional, but the line break must still be there.\n\nExample request:\n\n\texit\n\t\n\t\n\t{“message”:”Closing connection for no reason.”}\n\nAnother example, this time fatal:\n\n\texit\n\t1439948538953    -> Unix Timestamp\n\t3d532EfEQC       -> 10 Random [A-z0-9] Chars\n\t{“message”:”Server cannot recover from error in procedure call.”}\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/AGhost-7/pogostick/issues"
  },
  "homepage": "https://github.com/AGhost-7/pogostick#readme",
  "_id": "pogostick-proto@1.1.4",
  "_shasum": "03f043293404020e43df1f8e876de1507905dec9",
  "_from": "pogostick-proto@>=1.1.3 <2.0.0"
}
