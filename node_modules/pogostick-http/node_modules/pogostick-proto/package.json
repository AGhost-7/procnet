{
  "name": "pogostick-proto",
  "version": "1.2.8",
  "description": "Pogostick protocol functions",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/AGhost-7/pogostick.git"
  },
  "contributors": [
    {
      "name": "Jonathan Boudreau",
      "email": "jonathan.boudreau.92@gmail.com"
    }
  ],
  "scripts": {
    "ci": "npm run lint && npm run test",
    "test": "mocha",
    "lint": "jshint ."
  },
  "main": "index.js",
  "author": {
    "name": "AGhost-7"
  },
  "keywords": [
    "rpc",
    "server",
    "client"
  ],
  "engines": {
    "node": ">= 0.12"
  },
  "license": "MIT",
  "devDependencies": {
    "bluebird": "^2.9.34",
    "chai": "^3.2.0",
    "jshint": "^2.8.0",
    "lodash": "^3.10.1",
    "mocha": "^2.3.0"
  },
  "dependencies": {
    "extend": "^3.0.0",
    "mk-fn": "^1.0.0"
  },
  "readme": "# Pogostick Proto\n\nThe goal is to have a promises-based, high performance, and transport-agnostic RPC \nlibrary.\n\nDuplex connections are achieved by having a “client” and a “server” on both sides of the \nconnection.\n\nPrimary focus for this RPC is ensuring the future result is always completed.\nThis means if a network connection fails, it eagerly rejects the result instead \nof trying to reconnect. It is perfectly posssible to reconnect afterwards.\n\n## Introductory Example\n\n## Http Server\n```javascript\nvar pogo = require('pogostick-http');\n\n// Define default headers and other configurations.\nvar mkServer = pogo.server({\n\theaders: {\n\t\t'Content-Type': 'text/plain'\n\t}\n});\n// returns a http.Server instance\nvar server = mkServer({\n\tadd: function(a, b) {\n\t\treturn a + b;\n\t},\n\tfoo: {\n\t\tbar: function() {\n\t\t\treturn \"foobar\";\n\t\t}\n\t}\n});\n\nserver.listen(3003);\n```\n\n## Http Browser Client\n```javascript\nvar pogo = require('pogostick-browser');\nvar Promise = require('bluebird');\nvar promiseFactory = function(resolver) { return new Promise(resolver); };\nvar mkClient = pogo(promiseFactory, {\n\thost: 'localhost'\n});\n\nmkClient({ port: 3003 }, function(err, remote) {\n\tif(err) return console.log('there was an error loading the remote');\n\tPromise.all([\n\t\tremote.add(2, 4),\n\t\tremote.foo.bar()\n\t]).spread(function(sum, foo) {\n\t\tconsole.log('sum is:', sum);\n\t\tconsole.log('foobar is:', foo);\n\t});\n});\n```\n\n## Features\n\n### Deep Objects\nPogostick supports using objects as namespaces. It also supports arrays of \nfunctions.\n\n```javascript\n// Server\nvar server = mkServer({\n\tfoo: {\n\t\tbar: function() {\n\t\t\treturn \"foobar\";\n\t\t},\n\t\tbaz: function() {\n\t\t\treturn \"foobaz\";\n\t\t}\n\t}\n});\n// etc...\n\n// Client\nmkClient({ port: 3000 }, function(err, remote) {\n\tremote.foo.bar().then(function(res) {\n\t\tconsole.log('server says: ', res); // -> server says: foobar\n\t});\n});\n```\n\n### Pick-Your-Own Promises\nAs long as the library you choose follows the Promises/A+ specification, you\ncan use your favourite promises library. You just need to specify the factory\nfunction so that pogostick can instantiate the promises for you.\n\n```javascript\nvar Bluebird = require('bluebird');\nvar bluebirdMkClient = pogo.client(function(resolver) {\n\treturn new Bluebird(resolver);\n});\n\nvar Q = require('q');\nvar qMkClient = pogo.client(Q.Promise);\n\nvar when = require('when');\nvar whenMkClient = pogo.client(when.promise);\n```\n\n### Implicit Parameters\nImplicit parameters in Pogostick are inspired by Scala implicit parameters. \nThese were implemented to make it possible to pass authentication tokens and \nsuch into remote procedures without having to specify them every time. So,\nhere's an example:\n\nServer:\n```javascript\n...\nmkServer({\n\tgreet: function() {\n\t\t// You access the implicit values sent by the client through the \"this\"\n\t\t// keyword.\n\t\treturn \"hello \" + this.name + \"!\";\n\t}\n});\n...\n```\n\nClient:\n```javascript\nmkClient({ port: 3000 }, function(err, remote) {\n\tif(err) return console.log('there was an error loading the remote');\n\tvar withName = remote.$implicitly('name', 'AGhost-7');\n\t// Using withName, you will automatically send \"AGhost-7\" to the server.\n\twithName\n\t\t.greet()\n\t\t.then(console.log.bind(console));\n});\n```\n\nThe client in this case will print to the console `Hello AGhost-7`.\n\n\n\n\n\n## Protocol Specification\n\nThe protocol is composed of five methods. `ls`, `init`, `call`, `res`, `err` \nand `exit. The method being called is specified on the first line of the \nmessage. Each argument following are separated by a line break.\n\nIdentification of the remote calls is necessary for the implementation in raw \nprotocols such as TCP or UDP. Since the Pogostick protocol is transport \nagnostic, it includes such a requirement, even for the HTTP/HTTPS \nimplementation.\n\n### Implicits\nInspired by implicit parameters in the Scala language, implicits are \npogostick's answer to cookies: Pieces of data which are automatically sent to \nthe server, semi-persistent pieces of data between requests. They have some \nadditional limitations when compared to cookies, but for the most part, provide\na solution to the problem which comes from not relying on http as much as one \ncould.\n\nSince the protocol is transport-agnostic, which means it could technically be \nimplemented using a tcp connection or some other, I cannot rely on cookies, \nquery strings, or anything of that sort. The only solution which comes to mind \nis having pieces of data which are automatically sent in the request created by \nthe client.\n\n### Protocol Methods\n\n#### Proc Listing: `ls`\n\nThis is to enable compatibility with the implementation in http. The client must \ninitialize communication by sending a ls request to the server. Server does not \nsend the init packet until ls is requested.\n\n\tls              -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\n\n#### Initializer: `init`\n\nIn the initial request done by the client, the method listing for the server is \nsent to the client. This allows the api to be defined directly on the client \nobject given by the connection constructor. The protocol permits to transfer \narrays and objects for the purpose of namespacing. Strings and numbers are not \ntransferred over by the protocol, and are ignored by the client. The number \nsent at the key of the procedure specifies the number of arguments that the \nfunction accepts.\n\nFor example:\n\n\tinit                          -> Method Name\n\t1439948538953                 -> Unix Timestamp\n\t3d532EfEQC                    -> 10 Random [A-z0-9] Chars\n\t{“add”:2,”multiply”:2}        -> Procedure Listing\n\nAnother example:\n\n\tinit\n\t1439948538953                         -> Unix Timestamp\n\t3d532EfEQC                            -> 10 Random [A-z0-9] Chars\n\t{“add”: {“default”:3,”two”:2}}        -> Procedure Listing\n\n#### Function Call: `call`\n\nThe call method is sent by the client to the server to request information, or \njust signal a change of state. Since it is possible for multiple requests to be \npending, the next arguments a timestamp. long with a pseudo-random string is \nsubmitted to a maximum length of 10 characters, valid characters are A-z and \n0-9. The fourth argument is the procedure’s name, and the last are the \narguments. Only the arguments are a valid json array, where each element is an \nargument to be feed to the procedure call.\n\nNote: As long as there is still a connection, the server must respond.\n\n\tcall                   -> Method Name\n\t1439948538953          -> Unix Timestamp\n\t3d532EfEQC             -> 10 Random [A-z0-9] Chars\n\tadd.default            -> Procedure Call Name\n\t[1,2]                  -> Arguments Array\n\t{\"token\":\"jn13jnsc0j\"} -> Implicit parameters\n\n#### Function Response: `res`\n\nStamp must be the stamp the client sent when the procedure was called.\n\n\tres             -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\t3               -> Result\n\n#### Function Error: `err`\n\n\terr             -> Method Name\n\t1439948538953   -> Unix Timestamp\n\t3d532EfEQC      -> 10 Random [A-z0-9] Chars\n\t“Error!”        -> JSON value (string|number|object|integer)\n\n#### Closing Connection: `exit`\n\nExit can either represent a fatal error or a request by the client/server to \nend the connection. The second and third arguments are optional, but the line \nbreak must still be there.\n\nExample request:\n\n\texit\n\t\n\t\n\t{“message”:”Closing connection for no reason.”}\n\nAnother example, this time fatal:\n\n\texit\n\t1439948538953    -> Unix Timestamp\n\t3d532EfEQC       -> 10 Random [A-z0-9] Chars\n\t{“message”:”Server cannot recover from error in procedure call.”}\n\n\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/AGhost-7/pogostick/issues"
  },
  "homepage": "https://github.com/AGhost-7/pogostick#readme",
  "_id": "pogostick-proto@1.2.8",
  "_shasum": "49c6d99b2a0e507b31255f5ba1d07442aab770d3",
  "_from": "pogostick-proto@>=1.2.8 <2.0.0"
}
